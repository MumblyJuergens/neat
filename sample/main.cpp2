/* lang:cpp */
#include <neat/neat.hpp>
#include <glube/glube.hpp>
#include <neat/neatdrawgl.hpp>

using namespace neat::literals;
/* lang:end */

key_callback: (copy event: glube::KeyEvent) = 
{
    if event.key == glube::Key::escape && event.action == glube::KeyAction::pressed
    {
        event.window*.set_should_close(true);
    }
}

clear_console: () = std::print("\x1B[3J\x1B[H");
clear_console_properly: () = std::print("\x1B[2J\x1B[H");

Sim : type =
{
    this: neat::Simulation = ();
    
    step_count: std::size_t = 0;

    Entry : @struct type =
    {
        i0: neat::real_t = ();
        i1: neat::real_t = ();
        a: neat::real_t = ();
    }

    data: std::array<Sim::Entry, 4> = (
        :Sim::Entry = (0.0f, 0.0f, 0.0f),
        :Sim::Entry = (0.0f, 1.0f, 1.0f),
        :Sim::Entry = (1.0f, 0.0f, 1.0f),
        :Sim::Entry = (1.0f, 1.0f, 0.0f),
    );

    step: (override inout this, inout info: neat::SimulationInfo) =
    {
        to_bool: == :(f: neat::real_t) = f > 0.5_r;

        info.assign_inputs(1.0_r, data[step_count].i0, data[step_count].i1);

        info.run(std::tanhf);

        info.fitness += to_bool(info.outputs[0]) == to_bool(data[step_count].a);
        info.is_perfect = info.fitness > 3.5_r;
        info.is_done = step_count++ == std::size(data);
    }
}


main: () =
{
    windowSize: const glm::ivec2 = (1280,720);
    window: glube::Window = (windowSize.x, windowSize.y, "Neat Sample");
    window.set_key_event_handler(key_callback);

    diagrammer: neat::draw::gl::Diagrammer = (windowSize, 0);

    simulationFactory := :() = cpp2::shared.new<Sim>();

    cfg: neat::Config = ();
    cfg.setup_inital_connection_rate = 0.0_r;
    cfg.species_compatability_threshold = 5.0_r;

    population: neat::Population = (simulationFactory, cfg);
    speciesCount := 0;
    population.set_stats_string_handler(:(stats: std::string) =
        {
            pop := population&$;
            sc := speciesCount&$;
            if pop*.species_count() < sc*
            {
                clear_console_properly();
            }
            else
            {
                clear_console();
            }
            sc* = pop*.species_count();
            std::print("{}", stats);
        });

    champId: = -1;

    while !window.should_close()
    {
        glClear(GL_COLOR_BUFFER_BIT);

        population.step();

        clear_console();

        if population.generation_is_done()
        {
            if (population.finished())
            {
                //clear_console_properly();
                std::println("Perfection! Generation {}", population.generation());
                std::println("{}", population.champ().chart());
            }
            else {
                population.new_generation();
            }
        }

        if (population.champ_id() != champId)
        {
            champId = population.champ_id();
            diagrammer.build_diagram(population.champ());
        }

        diagrammer.draw_diagram();

        window.poll_events();
        window.swap_buffers();
    }
}